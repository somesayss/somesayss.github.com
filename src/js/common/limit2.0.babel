"use strict";
/**
 * 2015.10.8
 * 对ES的增强
 * version: 2.0.0
 * 更加优美的构造，入口的统一，ES6语法
 */
define(function(require, exports) {

	// 变量
	const limit = {};
	const WIN = window;
	const DOC = WIN.document;
	const BODY = DOC.body;
	const objectProto = Object.prototype;
	const arrayProto = Array.prototype;

	// 确定全局是否用兼容方法
	limit.limitFixed = false;
	limit.logClosed = true;

	// 自有属性
	const {defineProperty, is, assign, keys} = Object;
	const {toString, hasOwnProperty} = objectProto;
	const {concat, slice, forEach, map, filter, some, every} = arrayProto;

	// 传递器
	const K = (...args) => args.length <= 1 ? args[0] : args;

	// 空函数
	const E = () => {};

	// 空对象
	const O = {};

	// 获取属性
	const getProp = (obj = O, key = '', deVal) => obj[key] === void 0 ? deVal : obj[key];

	// 定义:priority,fixed,when,format
	const defineIt = (name, config = O) => {
		let priority, fixed, when, format, value;
		if( config.value === void 0 ){
			// 新方法
			priority = getProp(config, 'priority', K);
			// 兼容性方法
			fixed = getProp(config, 'fixed', K);
			// 条件 [默认为false]
			when = getProp(config, 'when', E);
			// 格式化参数
			format = getProp(config, 'format', K);
			// 主函数
			value = function(){
				let args = concat.call( arrayProto, format(...arguments) );
				return !limit.limitFixed && when(...args) ? priority(...args) : fixed(...args);
			};
		}else{
			value = config.value;
		};
		if( defineProperty ){
			defineProperty(limit, name, {
				value,
				writable: false, //只读
				enumerable: true, //被枚举
				configurable: false //更改内部属性
			});
		}else{
			if( limit[name] !== void 0){
				throw new TypeError('Cannot redefine property: ' + name);
			};
			limit[name] = value;
		};
		return value;
	};

	// 传递器
	defineIt('K', {value: K});

	// 获取属性
	defineIt('getProp', {value: getProp});

	// --错误日志-- //
		// 日志颜色
		let logColor = {
			'log': 'background:#333;margin-left:11px;padding-right:17px;',
			'error': 'background:#F00;padding-right:3px;',
			'warn': 'background:#F70;margin-left:11px;padding-right:10px;'
		};

		// 错误提醒
		let typeWarn = {
			toString: obj => limit.log('warn', obj, 'change into', '\''+obj+'\'', 'limit.toString is called'),
			toArray: obj => limit.log('warn', obj, 'change into []', 'limit.toArray is called'),
			formatDate: obj => limit.log('warn', 'timestamp:', timestamp, 'date:', date, 'limit.formatDate is called'),
			bind: obj => limit.log('warn', fun, 'type is not function, limit.bind is called')
		};

		// log
		defineIt('log', {
			value(...args){
				if(limit.logClosed) return;
				let type = args.shift(),
					con = console || O,
					log,
					isChrome = WIN.chrome;
				// 对type的处理可选值 'error'[默认]|'log'|'warn'
				// 这里可以优化用
				if( !limit.contains(['error', 'log', 'warn'], type) ){
					args.unshift(type);
					type = 'error';
				};
				log = con[type] || K;
				// IE10下的IE8调试模式，console.log是个对象 纯IE8下 log = K;
				try{
					isChrome && args.unshift(logColor[type]+'color:#FFF;padding-left:3px;border-radius:3px;');
					args.unshift( (isChrome ? '%c' : '') +'limitJS ' + type + ':');
					log.apply(con, args);
				}catch(e){
					log('日志 ', args);
				};
			}
		});

	// --判定方法-- //

		// 是否是DOM元素
		defineIt('isElement', { value: n => !!n && n.nodeType === 1 });

		// 判断是否是docuemtn
		defineIt('isDocument', { value: n => !!n && n.nodeType === 9 });

		// 判断是否是window
		defineIt('isWin', { value: n => !!n && n.window === n && n.self == n });

		// 是否是未定义undefined
		defineIt('isUndefined', { value: n => n === void 0 });

		// 是否是定义
		defineIt('isDefined', { value: n => !limit.isUndefined(n) });

		// 是否是空null
		defineIt('isNull', { value: n => n === null });

		// 是否是函数function
		defineIt('isFunction', { value: n => typeof n === 'function' });

		// 是否是布尔boolean
		defineIt('isBoolean', { value: n => n === true || n === false || toString.call(n) === '[object Boolean]' });

		// 是否是这些[string number array data regexp error]对象
		'String,Number,Array,Date,RegExp,Error,Math'.replace(/\w+/g, (k) => defineIt('is' + k, { value: n => toString.call(n) === '[object '+k+']' }) );

		// 是否是对象 除了5种基本类型以外都是对象
		defineIt('isObject', { value: n => limit.isFunction(n) || typeof n === 'object' && !!n });

		// 是否是参数
		defineIt('isArguments', { value: n => limit.has(n, 'callee') });

		// array arguments nodeList jObject string[排除] window[排除] function[排除]
		defineIt('isArrayLike', { value: n => !!n && limit.isNumber(n.length) && !limit.isFunction(n) && !limit.isWin(n) && !limit.isString(n) });

		// 是否是NaN
		defineIt('isNaN', { 
			when: () => !!Number.isNaN, 
			priority: (...args) => Number.isNaN(...args), 
			fixed: n => limit.isNumber(n) && isNaN(n) 
		});

		// 是否是有限的
		defineIt('isFinite', { 
			when: () => !!Number.isFinite, 
			priority: (...args) => Number.isFinite(...args), 
			fixed: n => limit.isNumber(n) && isFinite(n) 
		});

		// 是否为整数
		defineIt('isInteger', { 
			when: () => !!Number.isInteger, 
			priority: (...args) => Number.isInteger(...args), 
			fixed: n => limit.isFinite(n) && Math.floor(n) === n 
		});

		// 是否为安全整数
		defineIt('isSafeInteger', { 
			when: () => !!Number.isSafeInteger, 
			priority: (...args) => Number.isSafeInteger(...args), 
			fixed: n => limit.isInteger(n) && -9007199254740992 < n && n < 9007199254740992 
		});

		// 是否为空
		defineIt('isEmpty', {
			value: n => n == null || limit.size(n) === 0
		});

	// --检查参数-- //
		// 如果是null undefined 返回空对象
		const checkTargetNoEqualNull = (target, ...args) => target == null ? [{}, ...args] : [target, ...args];

		// 确定第一个参数是对象，第二个参数函数
		const checkObjFunction = (obj, iterator, context) => checkTargetNoEqualNull(obj, limit.cb(iterator), context);

	// --工具方法-- //

		// 私有遍历
		defineIt('_loop', {
			value: (obj, iterator, context, isBreak, begin) => {
				// 循环遍历
				let target = limit._getLoopKey(obj),
					key, num = ~~begin, len = target.length;
				for(; num < len; num++){
					key = target[num];
					if( iterator.call(context, obj[key], key, obj) === false && isBreak ) break;
				};
			}
		});

		// 获取键值
		defineIt('_getLoopKey', { value: obj => limit.isArrayLike(obj) ? limit.keys( limit.toArray(obj) ) : limit.keys(obj) });

		// 静态判定
		defineIt('has', {
			format: checkTargetNoEqualNull,
			fixed: (n, k) => hasOwnProperty.call(n, k)
		});

		// 确定是函数
		defineIt('cb', { value: callback => limit.isFunction(callback) ? callback : K });

		// 遍历
		defineIt('forin', {
			format: checkObjFunction,
			fixed(obj, iterator, context){
				for(let key in obj){
					iterator.call(context, obj[key], key, obj);
				};
			}
		});

		// 循环
		defineIt('each', {
			format: checkObjFunction,
			when: (obj) => isArrayLike(obj) && forEach,
			priority: (obj, iterator, context) => forEach.call(obj, (val, key) => { iterator.call(this, val, ''+key) }, context),
			value: (obj, iterator, context) => limit._loop(obj, iterator, context)
		});

	// --对象方法-- //
		// ES6: Object.is();
		defineIt('is', {
			when: () => !!is,
			priority: (...args) => is(...args),
			fixed(a, b){
				// 区分NaN
				if( limit.isNaN(a) && limit.isNaN(b)){
					return true;
				};
				// 区分 +0 -0
				if( a === 0 && b === 0){
					return 1/a === 1/b;
				};
				return a === b;
			}
		});

		// ES6: Object.assign();
		defineIt('assign', {
			when: () => !!assign,
			priority: (...args) => assign(...args),
			format: checkTargetNoEqualNull,
			fixed(target, ...args){
				limit.each(args, val => {
					limit.each(val, (val, key) => {
						target[key] = val;
					});
				});
				return target;
			}
		});

		// ES5: Object.keys
		defineIt('keys', {
			when: () => !!keys,
			priority: (...args) => keys(...args),
			format: checkTargetNoEqualNull,
			fixed(obj){
				let arr = [];
				limit.forin(obj, (val, key) => limit.has(obj, key) && arr.push(key) );
				return arr;
			}
		});

		// mix: extend
		defineIt('extend', {
			format: checkTargetNoEqualNull,
			fixed(target, ...args){
				limit.each(args, val => {
					limit.forin(val, (val, key) => {
						target[key] = val;
					});
				});
				return target;
			}
		});

		// mix: size
		defineIt('size', {
			value: n => limit._getLoopKey(n).length
		});

	// --数组-- //

		// mix: toArray
		defineIt('toArray', {
			value: obj => {
				// 如果是数组原始返回
				if( limit.isArray(obj) ){
					return obj;
				}else if( limit.isArrayLike(obj) ){ // 如果是类数组对象的话就格式化数组
					return slice.call(obj);
				}else{
					return ( typeWarn.toArray(obj), [] );
				};
			}
		});

		// ES5: forEach [支持obj]
		defineIt('forEach', {
			format: checkObjFunction,
			when: (arr) => arr.forEach && forEach,
			priority: (arr, iterator, context) => forEach.call(arr, iterator, context),
			fixed: (arr, iterator, context) => {
				return limit.isArrayLike(arr) ? limit.each(arr, (val, key) => {
					iterator.call(context, val, +key, arr);	
				}, context) : limit.each(arr, iterator, context);
			}
		});

		// ES5: map [支持obj]
		defineIt('map', {
			format: checkObjFunction,
			when: (arr) => arr.map && map,
			priority: (arr, iterator, context) => map.call(arr, iterator, context),
			fixed: (arr, iterator, context) => {
				// 初始化数组
				let result = limit.isArray(arr) ? [] : {};
				// 遍历
				limit.each(arr, function(val, key){
					result[key] = iterator.call(this, val, key, arr);
				}, context);
				return result;
			}
		});

		// ES5: filter [支持obj]
		defineIt('filter', {
			format: checkObjFunction,
			when: (arr) => arr.filter && filter,
			priority: (arr, iterator, context) => filter.call(arr, iterator, context),
			fixed: (arr, iterator, context) => {
				// 初始化数组
				let isArr = limit.isArray(arr),
					result = isArr ? [] : {};
				isArr ? limit.each(arr, function(val, key){
					iterator.call(this, val, key, arr) && result.push(val);
				}, context) : limit.each(arr, function(val, key){
					iterator.call(this, val, key, arr) && (result[key] = val);
				});
				return result;
			}
		});

		// ES5: some [支持obj]
		defineIt('some', {
			format: checkObjFunction,
			when: (arr) => arr.some && some,
			priority: (arr, iterator, context) => some.call(arr, iterator, context),
			fixed: (arr, iterator, context) => {
				// 初始化
				let result = false;
				limit.isArray(arr) ? limit._loop(arr, (val, key) => {
					if( iterator.call(context, val, +key, arr) ) return result = true, false;
				}, undefined, true) : limit._loop(arr, (val, key) => {
					if( iterator.call(context, val, key, arr) ) return result = true, false;
				}, undefined, true);
				return result;
			}
		});

		// 
		defineIt('every', {
			format: checkObjFunction,
			when: (arr) => arr.every && every,
			priority: (arr, iterator, context) => every.call(arr, iterator, context),
			fixed: (arr, iterator, context) => {
				return limit.some(arr, iterator, context);
			}
		});



	// --函数-- //

		// Promise
		class MyPromise {
			constructor(...args){
				// 状态值
				this.PromiseStatus = 'pedding';
				// 返回值
				this.PromiseValue = undefined;
				// 栈区
				this.Stack = [];
				if( limit.isFunction(args[0]) ){
					this.promiseList = [];
					let fun = args[0];
					let resolve = (val) => {
						limit.each([this].concat(this.promiseList), promise => {
							if(promise.PromiseStatus === 'pedding'){
								promise.PromiseStatus = 'resolved';
								promise.PromiseValue = val;
								promise._clean();
							};
						});
					};
					let reject = (val) => {
						limit.each([this].concat(this.promiseList), promise => {
							if(promise.PromiseStatus === 'pedding'){
								promise.PromiseStatus = 'rejected';
								promise.PromiseValue = val;
								promise._clean();
							};
						});
						setTimeout(() => {
							if(!this.promiseList.length){
								throw '(in promise) ' + val; 
							};
						}, 0);
					};
					try{
						fun(resolve, reject);
					}catch(e){
						this.PromiseStatus = 'rejected';
						this.PromiseValue = e;
					};
				}else{
					this.PromiseStatus = args[0];
					this.PromiseValue = args[1];
				};
			}
			then(suc, err){
				suc = limit.cb(suc);
				err = limit.cb(err);
				let me = this;
				if(me.promiseList){
					let originMe = me;
					me = new MyPromise(me.PromiseStatus, me.PromiseValue);
					originMe.promiseList.push(me);
				};
				me.Stack.push({suc, err});
				if(me.PromiseStatus !== 'pedding' && !me.cleanStatus){
					me._clean();	
				};
				return me;
			}
			Catch(err){
				return this.then(null, err);
			}
			_clean(){
				let me = this,
					one = me.Stack.shift();
				me.cleanStatus = 'init';
				if(one){
					setTimeout(() => {
						try{
							switch(me.PromiseStatus){
								case 'resolved':
									me.PromiseValue = one.suc(me.PromiseValue);
								break;
								case 'rejected':
									me.PromiseValue = one.err(me.PromiseValue);
								break;
							};
							me.PromiseStatus = 'resolved';
						}catch(e){
							me.PromiseStatus = 'rejected';
							me.PromiseValue = e;
							if(!me.Stack.length){
								setTimeout(() => {
									throw '(in promise) ' + e;
								}, 0);
							};
						};
						me._clean();
					}, 0);
				}else{
					delete me.cleanStatus;
				};
				return me;
			}
			static all(list){
				let guid = list.length,
					back,
					args = [];
				function main(arg, key){
					args[key] = arg;
					if(!--guid){
						back(args);
					};
				};
				return new MyPromise((resolve, reject) => {
					back = resolve;
					limit.each(list, (val, key) => {
						// Promise对象
						if(val.PromiseStatus){
							val.then(sucVal => {
								main(sucVal, key);
							}, errVal => {
								reject(errVal);
							});
						}else{
							main(val, key);
						};
					});
				});
			}
			static race(list){
				return new MyPromise((resolve, reject) => {
					limit.each(list, val => {
						MyPromise.resolve(val).then( sucVal => resolve(sucVal), errVal => reject(errVal) );
					});
				});
			}
			static resolve(val){
				if(val && val.then){
					return new MyPromise((resolve, reject) => {
						val.then(resolve, reject);
					});
				};
				return new MyPromise((resolve, reject) => {
					resolve(val);
				});
			}
			static reject(val){
				return new MyPromise((resolve, reject) => {
					reject(val);
				});
			}
		};
		// 
		if(WIN.Promise){
			Promise.prototype.Catch = function(fn){
				return this.then(null, fn);
			};
		};
		defineIt('promise', {
			when: () => !!WIN.Promise,
			priority: () => Promise,
			fixed: () => MyPromise
		});

	// 返回主体
	return limit;

});